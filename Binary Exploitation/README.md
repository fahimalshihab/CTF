# PWN
An Introduction to PWN Challenges
PWN challenges are a type of CTF challenge that require you to exploit a binary typically running on a remote server. This can be done by exploiting a vulnerability in the binary, or by using a vulnerability in the binary to gain access to the system.

Often, PWN challenges will require you to gain access to a remote server, and then exploit the binary on that server. This is done by connecting to the server using a tool such as netcat, and then sending commands to the server.


## Basic
```file xyz```
<code>
iftx@iftx-Modern-15-A5M:~/Desktop/00-intro_setup_basics$ file vuln
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=40bfd0a2a6007a83be654c0626aedb3bc95a133f, for GNU/Linux 3.2.0, not stripped

</code>

- Not stripped means if we reverse we will able to see the functions and etc.
-  Dynamic linking is when external or shared libraries are copied into the executable file by name right at the point of run time. It's only then that any required libraries are loaded to memory by the operating system. During dynamic linking, the operating system locates the external libraries when the program is run.

## What is Buffer Overflow?
A buffer is a sequential memory allocation or region that might hold anything from integer arrays to character strings. The purpose of the buffer area is to hold program or application data while it is being moved from one program to another, or between sections of a program.

A buffer overflow happens when a program either tries to place data in a memory area past the buffer, or attempts to put more data in a buffer than it can hold. Writing data beyond an allocated memory block’s bounds can crash the program, corrupt data, or allow an attacker to execute malicious code.

Malformed input data—inputs that are the wrong size by design—may trigger overflows. This is possible because in many cases, designers assume all inputs will be smaller than a threshold size and create the buffer to fit that size. In these situations, some anomalous transactions can write past the edge of the buffer by producing more data.

Buffer overflows are among the most serious software weaknesses that attackers can exploit. This is because detecting and repairing buffer overflows is difficult, particularly when the software is very complicated. Sometimes buffer overrun bug fixes themselves are error-prone and complex. And even in cases where software has been fixed many times, many buffer overflow security risks may remain.

## What is Buffer Overflow Attack?

![image](https://github.com/fahimalshihab/CTF/assets/97816146/ead02f95-b225-4dc9-9641-df4060009d43)


- Buffer: A buffer is a temporary storage area in a program's memory used to hold data.expand_more It's like a container with a specific size limit.exclamation

- Overflow: When a program tries to put more data into the buffer than it can hold, it's like overfilling the container. This excess data spills over and starts to overwrite adjacent memory locations.expand_more

- Attacker's Goal: Attackers can exploit this overflow to inject malicious code into the program's memory.expand_more  Imagine the attacker sneaking extra ingredients (malicious code) into your recipe (program) by overflowing the container (buffer).

- Code Execution: If the attacker crafts the overflow data carefully, they can overwrite the program's instructions with their own malicious code.expand_more  This is like replacing the recipe instructions with something the attacker wants the program to do instead.

- Taking Control: By replacing instructions, the attacker can potentially take control of the program, steal data, install malware, or disrupt system functions.  This gives the attacker power over the program, just like following a malicious recipe could lead to unintended consequences.

#### Here's an analogy:

Imagine a baker following a recipe that requires 1 cup of flour. If the measuring cup only holds 1 cup, but the baker accidentally adds 2 cups, the extra flour spills over and might ruin other ingredients nearby. An attacker could exploit this overflow by sneaking in a spoonful of something nasty (malicious code) along with the extra flour. This could potentially alter the final product (program's behavior) in unexpected ways.
#### Example

Here is a c code
```
#include <stdio.h>
#include <string.h>

int main(void)
{
    char buffer[16];

    printf("Give me data plz: \n");
    gets(buffer);
    
    return 0;
}
```
<b>Buffer Overflow Risk:</b> ```gets``` function

gets doesn't perform any bounds checking. It blindly reads characters from user input until it encounters a newline character (\n) or reaches the end of the file (EOF).
If the user enters more data than the allocated buffer size (buffer in your example), gets will continue writing past the buffer boundaries, overwriting adjacent memory locations.

<b>Why fgets is a Safer Alternative:</b> ```fgets```

fgets takes a maximum size parameter, ensuring it reads at most that many characters (including the null terminator) into the buffer.
It stops reading upon encountering a newline or reaching the size limit, preventing buffer overflows.

![image](https://github.com/fahimalshihab/CTF/assets/97816146/18b479e7-34ef-4ecb-834a-8d614f759d29)

```
─────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────
*EAX  0x8049172 (main) ◂— lea ecx, [esp + 4]
*EBX  0xf7e2a000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x229dac
*ECX  0xffffcea0 ◂— 1
*EDX  0xffffcec0 —▸ 0xf7e2a000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x229dac
*EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0
*ESI  0xffffcf54 —▸ 0xffffd14a ◂— '/home/iftx/Desktop/00-intro_setup_basics/vuln'
*EBP  0xffffce88 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— 0
*ESP  0xffffce80 —▸ 0xffffcea0 ◂— 1
*EIP  0x8049181 (main+15) ◂— sub esp, 0x10
```
These are registers,
here in this code we can see the gets function is taking 16 caracters but if we overflow this with morethan 16, its gonna destroy it self.

![image](https://github.com/fahimalshihab/CTF/assets/97816146/824f03ff-0cb0-4d44-8052-8edcf7949d0d)

<i>Normally regesters has there own works to do but now here its a great example of buffer overflow .now we can see all regesters are full of a's .</i>



## checkse 

``` checksec --file login```


![image](https://github.com/fahimalshihab/CTF/assets/97816146/bc44baa4-7342-41fa-8e73-e1fd7c84b19b)



- Arch: i386-32-little

  This indicates that the executable is designed for 32-bit systems using the little-endian architecture, which is the most common byte ordering for Intel x86 processors.

- RELRO: Partial RELRO
Partial RELRO (Relocation Read-Only) is a security feature that protects certain parts of the executable from being tampered with at runtime. In this case, only part of the relocation table is read-only.

- Stack: No canary found
The stack is a region of memory used by the program to store temporary data. A canary is a random value placed on the stack to detect buffer overflows, a common exploit technique. The absence of a canary means this executable might be more vulnerable to such attacks.

- NX: NX unknown - GNU_STACK missing
NX (No-eXecute) is a hardware feature that prevents code from being executed in data sections of memory. Here, it's unclear whether NX is enabled because the GNU_STACK executable flag is missing.

- PIE: No PIE (0x8048000)
Position-independent executable (PIE) is a security technique that loads the executable at a random address in memory. This makes it harder for attackers to exploit vulnerabilities using absolute memory addresses. The address (0x8048000) suggests PIE is not enabled.

- Stack: Executable
This means the program can execute code from the stack, which is usually undesirable and can be a sign of vulnerabilities.

- RWX: Has RWX segments
The executable has segments that are readable (R), writable (W), and executable (X). This is not necessarily a security concern, but it depends on the intended functionality of the program.

- Stripped: No
This means that the executable contains debugging symbols, which can be useful for analysis but also reveal information about the program's internal workings.


## 
```gcc login.c -o login -fno-stack-protector -z execstack -no-pie -m32```

### Example
![image](https://github.com/fahimalshihab/CTF/assets/97816146/f486e1e3-beeb-4e1a-87a1-59f7df3dfb0a)

```gcc vuln.c -o  vuln -fstack-protector-all ```

Is enabling all the protections
