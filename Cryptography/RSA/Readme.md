# Basic RSA
```
from Crypto.Util.number import inverse, long_to_bytes
n = 408579146706567976063586763758203051093687666875502812646277701560732347095463873824829467529879836457478436098685606552992513164224712398195503564207485938278827523972139196070431397049700119503436522251010430918143933255323117421712000644324381094600257291929523792609421325002527067471808992410166917641057703562860663026873111322556414272297111644069436801401012920448661637616392792337964865050210799542881102709109912849797010633838067759525247734892916438373776477679080154595973530904808231
e = 65537
c = 226582271940094442087193050781730854272200420106419489092394544365159707306164351084355362938310978502945875712496307487367548451311593283589317511213656234433015906518135430048027246548193062845961541375898496150123721180020417232872212026782286711541777491477220762823620612241593367070405349675337889270277102235298455763273194540359004938828819546420083966793260159983751717798236019327334525608143172073795095665271013295322241504491351162010517033995871502259721412160906176911277416194406909
p = 15485863
q = 26384008867091745294633354547835212741691416673097444594871961708606898246191631284922865941012124184327243247514562575750057530808887589809848089461174100421708982184082294675500577336225957797988818721372546749131380876566137607036301473435764031659085276159909447255824316991731559776281695919056426990285120277950325598700770588152330565774546219611360167747900967511378709576366056727866239359744484343099322440674434020874200594041033926202578941508969596229398159965581521326643115137

phi = (p - 1) * (q - 1)
d = inverse(e, phi)

m = pow(c, d, n)
flag = long_to_bytes(m).decode()
print(flag)
```
# hastad attck (3n,3c) 
```
from sympy.ntheory.modular import crt
from gmpy2 import iroot

n = [ 86812553978993,81744303091421,83695120256591 ]
c = [8875674977048,70744354709710, 29146719498409 ]
e=3
  
resultant, mod = crt(n,c)
value, is_perfect = iroot(resultant,e)
if is_perfect:
   print(value)
```
# Wiener ( e is a large one )

We get a setup for a RSA challenge. Since e is fairly huge we can assume d might be small so we can try our luck with Wiener's attack. 
Ex : [ciphertext](ciphertext.txt)

```
import owiener
from Crypto.Util.number import *

ct = bytes_to_long(open("ciphertext.txt", "rb").read()) 
e = 98161001623245946455371459972270637048947096740867123960987426843075734419854169415217693040603943985614577854750928453684840929755254248201161248375350238628917413291201125030514500977409961838501076015838508082749034318410808298025858181711613372870289482890074072555265382600388541381732534018133370862587
n = 689061037339483636851744871564868379980061151991904073814057216873412583484720768694905841053416938972235588548525570270575285633894975913717130070544407480547826227398039831409929129742007101671851757453656032161443946817685708282221883187089692065998793742064551244403369599965441075497085384181772038720949

d = owiener.attack(e, n)  
c = pow(ct, d, n)
                                                                
print("c:",long_to_bytes(c))

```
